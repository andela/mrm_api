from datetime import datetime
import graphene
from helpers.auth.authentication import Auth
from graphene_sqlalchemy import SQLAlchemyObjectType
from api.response.models import Response as ResponseModel
from utilities.validations import validate_empty_fields
from graphql import GraphQLError
from api.room.schema import Room
from api.question.models import Question as QuestionModel
from helpers.response.create_response import create_response


class Response(SQLAlchemyObjectType):
    """
        Autogenerated return type of a response
    """
    class Meta:
        model = ResponseModel


class ResponseInputs(graphene.InputObjectType):
    question_id = graphene.Int(
        required=True, description="Unique identifier field of a question")
    rate = graphene.Int(description="Id field of where the response is made")
    text_area = graphene.String(description="The rate field of response inputs")
    missing_items = graphene.List(
        graphene.Int, description="Number field of the missing items")


class CreateResponse(graphene.Mutation):
    """
        Returns response payload on creating a response
    """
    class Arguments:
        responses = graphene.List(ResponseInputs, required=True)
        room_id = graphene.Int(required=True)

    response = graphene.List(Response)

    def mutate(self, info, **kwargs):
        validate_empty_fields(**kwargs)
        query = Room.get_query(info)
        responses = []
        errors = []
        present_date = datetime.now().strftime('%Y/%m/%d %H:%M:%S')
        room = query.filter_by(id=kwargs['room_id']).first()
        if not room:
            raise GraphQLError("Non-existent room id")
        for each_response in kwargs['responses']:
            question = QuestionModel.query.filter_by(
                id=each_response.question_id).first()
            if not question:
                errors.append(
                    "Response to question {} was not saved because it does not exist".format(each_response.question_id)) # noqa
                continue
            if present_date < question.start_date:
                errors.append(
                    "The start date for the response to this question is yet to commence. Try on {}".format(question.start_date)) # noqa
            question_type = question.question_type
            each_response['room_id'] = kwargs['room_id']
            responses, errors = create_response(question_type,
                                                errors,
                                                responses,
                                                **each_response)
        if errors:
            raise GraphQLError(
                ('The following errors occured: {}').format(
                    str(errors).strip('[]'))
                )
        return CreateResponse(response=responses)


class Query(graphene.ObjectType):
    """
        Query to get the room response
    """
    get_room_response = graphene.List(
        Response,
        room_id=graphene.Int(),
        description="Returns a list of responses of a room. Accepts the arguments\
            \n- room_id: Unique identifier of a room"
    )

    @Auth.user_roles('Admin')
    def resolve_get_room_response(self, info, **kwargs):
        # Get the room's feedback
        query = Response.get_query(info)
        room_feedback = query.filter_by(room_id=kwargs['room_id'])
        if room_feedback.count() < 1:
            raise GraphQLError("No Feedback Found")
        return room_feedback


class HandleRoomResponse(graphene.Mutation):
    """
        Returns payload on marking or unmarking
        a response as resolved
    """
    class Arguments:
        response_id = graphene.Int()

    room_response = graphene.Field(Response)

    @Auth.user_roles('Admin')
    def mutate(self, info, response_id, **kwargs):
        query_responses = Response.get_query(info)
        room_response = query_responses.filter(
            ResponseModel.id == response_id).first()
        if not room_response:
            raise GraphQLError("Response does not exist")
        if room_response.resolved:
            room_response.resolved = False
            room_response.save()
        else:
            room_response.resolved = True
            room_response.save()
        return HandleRoomResponse(room_response=room_response)


class Mutation(graphene.ObjectType):
    create_response = CreateResponse.Field(
        description="Mutation to create a new response taking the arguments\
            \n- responses: Field for the response inputs\
            \n- room_id: Unique key identifier of the room where the response \
            is made")
    resolve_room_response = HandleRoomResponse.Field(
        description="Mutation to mark or unmark a response as resolved\
            \n- room_response: Field for the response inputs\
            \n- response_id: Unique key identifier of a room_response"
    )
